---
description: 
globs: 
alwaysApply: false
---
---
save_at: docs/sec_checklist.md
tags: security, checklist, pentest
current_task: Security Checklist Start
---

# Security Checklist

**Instructions:** There are several sections for different domains of security to test. Each section has several items with sub-checks. Perform the sub-checks one by one and mark them as done `[x].
When an item is complete fill in `Status:` as `PASS` or `FAIL`, `Remarks:` with the details and then mark the item as done. Then stop for confirmation, unless requested otherwise.
Asume all security tools are installed.

## Input/Output Security

* [ ] Inputs are sanitized from injection metacharacters. Status:  Remarks:

  * [ ] Search for user inputs via HTTP (e.g., GET/POST) arguments.
  * [ ] Search for user inputs via HTTP headers.
  * [ ] Search for user inputs via URL parameters.
  * [ ] Search for user inputs via cookies.
  * [ ] Search for user inputs via file uploads.
  * [ ] Search for user inputs via command-line arguments.
  * [ ] Search for user inputs via inter-process communication (IPC).
  * [ ] Search for user inputs via environment variables.
  * [ ] Search for user inputs via external services or APIs.
  * [ ] Search for user inputs via mobile device sensors (e.g., GPS, accelerometer).
  * [ ] Search for user inputs via local storage or databases.
  * [ ] Search for user inputs via third-party libraries or plugins.
  * [ ] Search for user inputs via user-generated content (e.g., comments, messages).
  * [ ] Search for user inputs via email or messaging services.
  * [ ] Search for user inputs via uploaded documents or media files.

* [ ] Input data types are strictly defined (Type Confusion). Status:  Remarks:

  * [ ] Review code for type declarations and ensure they match expected input types.
  * [ ] Check for the use of strong typing in function parameters and return values.
  * [ ] Verify that input validation enforces correct data types.
  * [ ] Ensure that type casting is handled safely and does not lead to unexpected behavior.
  * [ ] Look for the use of serialization/deserialization and validate the data types involved.
  * [ ] Examine API endpoints to confirm they enforce expected data types.
  * [ ] Assess the use of reflection or dynamic code execution that may bypass type checks.
  * [ ] Evaluate the use of JSON/XML parsers and ensure they enforce schema validation.
  * [ ] Check for the use of generic data structures (e.g., maps, lists) and validate their contents.
  * [ ] Review input from external sources to ensure it is parsed and handled with strict type checks.

* [ ] Output encoding is context-sensitive (HTML, JSON, XML, etc.). Status:  Remarks:

  * [ ] Identify all output contexts (HTML, JavaScript, CSS, URL, JSON, XML).
  * [ ] Ensure that output encoding is applied appropriately for each context.
  * [ ] Verify that encoding libraries or functions are used consistently.
  * [ ] Check for instances where output is concatenated without proper encoding.
  * [ ] Review templates and rendering engines for automatic encoding features.
  * [ ] Examine API responses to ensure data is serialized safely.
  * [ ] Assess logging mechanisms to confirm sensitive data is encoded or masked.
  * [ ] Evaluate error messages for proper encoding to prevent information leakage.
  * [ ] Inspect data exports (e.g., CSV, Excel) for proper encoding of special characters.
  * [ ] Confirm that user-generated content is sanitized and encoded before display.

* [ ] Input validation is performed on the server side. Status:  Remarks:

  * [ ] Review server-side code to ensure validation logic is present.
  * [ ] Check for duplication of validation logic on both client and server sides.
  * [ ] Verify that server-side validation handles all input sources.
  * [ ] Assess the use of validation frameworks or libraries on the server.
  * [ ] Examine API endpoints for comprehensive input validation.
  * [ ] Ensure that server-side validation enforces business rules and constraints.
  * [ ] Evaluate error handling for invalid inputs on the server.
  * [ ] Confirm that server-side validation is not bypassed through direct API calls.
  * [ ] Review authentication and authorization mechanisms for input validation.
  * [ ] Check for logging of validation failures for monitoring and auditing purposes.

* [ ] Input validation uses a positive security model (allowlist). Status:  Remarks:

  * [ ] Identify all input fields and define acceptable input patterns.
  * [ ] Implement allowlist validation for each input based on defined patterns.
  * [ ] Avoid reliance on blocklists or negative validation approaches.
  * [ ] Use regular expressions to enforce strict input formats.
  * [ ] Validate input lengths and enforce minimum and maximum constraints.
  * [ ] Restrict input character sets to only those necessary.
  * [ ] Apply input validation consistently across all application components.
  * [ ] Utilize validation libraries that support allowlist approaches.
  * [ ] Document validation rules for maintainability and clarity.
  * [ ] Test validation logic with both valid and invalid inputs to ensure effectiveness.

* [ ] Output encoding is applied consistently across all outputs. Status:  Remarks:

  * [ ] Audit all output-generating code paths for encoding practices.
  * [ ] Ensure that encoding is applied uniformly, regardless of output destination.
  * [ ] Verify that encoding functions are not bypassed or disabled.
  * [ ] Check for the use of centralized encoding utilities or services.
  * [ ] Review third-party libraries for their handling of output encoding.
  * [ ] Confirm that dynamic content is encoded before insertion into templates.
  * [ ] Assess the handling of special characters in outputs to prevent injection.
  * [ ] Evaluate the encoding of data stored in logs or audit trails.
  * [ ] Inspect exported data formats for proper encoding of fields.
  * [ ] Monitor for inconsistencies in encoding practices that may lead to vulnerabilities.

---

## Database Querying Security

* [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
* OWASP Secure Coding Practices – Database Security section
* Vendor-specific database security best practices (e.g., MySQL, PostgreSQL, MSSQL)

* [ ] Database queries are parameterized (Database Query Injection). Status:  Remarks:

  * [ ] Identify all dynamic SQL query constructions in code.
  * [ ] Ensure that parameterized queries (e.g., `?`, `$1`) are used instead of string concatenation.
  * [ ] Review ORM (Object-Relational Mapping) configurations to confirm safe query generation.
  * [ ] Check stored procedures or prepared statements for proper binding of variables.
  * [ ] Validate that input passed into queries is never directly inserted without sanitization.
  * [ ] Search for raw SQL usage in the application and verify that it's parameterized.
  * [ ] Review logging for any SQL statements to detect possible injection attempts.
  * [ ] Run automated scanners or linters to detect insecure SQL patterns.
  * [ ] Validate input constraints (length, type) before query execution.

* [ ] Use stored procedures when necessary (Race Condition). Status:  Remarks:

  * [ ] Identify critical operations (e.g., financial transfers, state changes) that require atomicity.
  * [ ] Check that stored procedures are used to enforce transactional integrity.
  * [ ] Validate stored procedures for safe input handling and consistent logic.
  * [ ] Ensure stored procedures use appropriate locking to prevent race conditions.
  * [ ] Verify that sensitive logic is encapsulated in the database layer to reduce client-side manipulation risk.
  * [ ] Assess isolation levels set in database transactions (e.g., READ COMMITTED, SERIALIZABLE).
  * [ ] Review for use of application-side logic that could result in race conditions instead of atomic operations.
  * [ ] Check that retry logic for failed transactions is implemented safely and idempotently.
  * [ ] Use logging or monitoring to detect signs of race condition exploitation (e.g., duplicate record inserts).

---

## Authentication Security

* [OWASP ASVS v4.0 – Section 2 (Authentication)](https://github.com/OWASP/ASVS)
* [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
* [NIST SP 800-63B: Digital Identity Guidelines](https://pages.nist.gov/800-63-3/sp800-63b.html)


* [ ] All parts of the authentication are done on the server side. Status:  Remarks:

  * [ ] Inspect client-side code to ensure it does not perform password verification.
  * [ ] Confirm that no sensitive authentication logic exists in JavaScript, mobile apps, or frontend frameworks.
  * [ ] Ensure that credentials are submitted to a secure backend endpoint over HTTPS.
  * [ ] Review API endpoints for proper credential handling and validation on the server.
  * [ ] Analyze logs for any signs of client-side verification bypass attempts.

* [ ] Application behavior is standardized (User Enumeration). Status:  Remarks:

  * [ ] Check for consistent error messages regardless of whether the username or password is incorrect.
  * [ ] Inspect responses for side channels (timing, content length, status codes) that may leak user existence.
  * [ ] Validate password reset, login, and registration flows for user enumeration risks.
  * [ ] Confirm CAPTCHA or rate limiting is used to throttle enumeration attempts.
  * [ ] Conduct black-box testing to attempt user discovery.

* [ ] Autocomplete is disabled. Status:  Remarks:

  * [ ] Inspect HTML form fields for `autocomplete="off"` on username and password fields.
  * [ ] Validate that sensitive fields (e.g., current password, SSN) do not cache data in browsers.
  * [ ] Check mobile forms as well for autocomplete or autofill behaviors.

* [ ] Password complexity control is implemented. Status:  Remarks:

  * [ ] Verify enforcement of a minimum length (≥ 8 characters) and required character sets.
  * [ ] Ensure dictionary or commonly used password checks are in place.
  * [ ] Confirm real-time feedback for password strength on the UI.
  * [ ] Validate password rules with automated testing and manual account creation attempts.
  * [ ] Ensure policies align with NIST 800-63 (e.g., no forced periodic resets unless compromise suspected).

* [ ] Multi-factor authentication (MFA) is implemented. Status:  Remarks:

  * [ ] Confirm at least two different factors are required (e.g., password + TOTP, U2F).
  * [ ] Validate integration with MFA providers (e.g., Authy, Duo, Google Authenticator).
  * [ ] Ensure fallback methods are secure (e.g., recovery codes, hardware token).
  * [ ] Test resilience against OTP reuse, replay, and time manipulation.
  * [ ] Review MFA enforcement on all critical paths (login, sensitive operations).

* [ ] Lockout mechanism for successive failed login attempts is implemented. Status:  Remarks:

  * [ ] Check for account lockout or delay after N failed attempts.
  * [ ] Confirm that lockout applies per-user and/or per-IP with rate limiting.
  * [ ] Ensure lockout duration is reasonable (temporary or requires manual reset).
  * [ ] Validate that lockout status does not leak user enumeration info.
  * [ ] Monitor logs for brute force attempts or account lock abuse.

* [ ] Secure CAPTCHA is implemented. Status:  Remarks:

  * [ ] Confirm CAPTCHA is used on public forms (login, registration, forgot password).
  * [ ] Verify CAPTCHA can't be bypassed via API or direct POST requests.
  * [ ] Test for CAPTCHA accessibility and usability.
  * [ ] Ensure CAPTCHA is triggered based on heuristics (e.g., geoIP, user-agent anomalies).

* [ ] No IDORs to access other customer data (IDOR). Status:  Remarks:

  * [ ] Manually test endpoints that take user or object IDs as parameters.
  * [ ] Verify access controls are enforced server-side for every object reference.
  * [ ] Check that UUIDs or non-guessable IDs are used, but also enforced with authorization.
  * [ ] Use fuzzing tools to try accessing resources belonging to other users.
  * [ ] Review logs or backend logic for conditional access logic failures.

---

## User Session Security

* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
* [OWASP ASVS v4.0 – Section 3 (Session Management)](https://github.com/OWASP/ASVS)
* NIST SP 800-63B recommendations for session handling


* [ ] Session idle timeout is configured. Status:  Remarks:

  * [ ] Review application/session config for session expiration timeout (e.g., 15–30 minutes of inactivity).
  * [ ] Verify timeout resets on user activity (e.g., mouse movement, AJAX requests).
  * [ ] Test for session persistence beyond idle timeout manually.
  * [ ] Validate logout or timeout leads to proper session destruction.
  * [ ] Confirm session timeout is not overridden by client-side logic (e.g., JavaScript hacks).

* [ ] Sessions are expired after logout. Status:  Remarks:

  * [ ] Confirm session tokens/cookies are invalidated on server after logout.
  * [ ] Check browser behavior after logout—manual revisit or back navigation shouldn't restore session.
  * [ ] Use tools like Burp or Postman to replay session tokens after logout and ensure access is denied.
  * [ ] Review backend logic to ensure server-side token invalidation and storage clearance.

* [ ] Session keys are in no way predictable. Status:  Remarks:

  * [ ] Examine session key/token format for randomness (use entropy estimation tools if needed).
  * [ ] Confirm use of secure cryptographic random number generators for token generation.
  * [ ] Check for any static or guessable patterns in session tokens (e.g., base64-encoded usernames).
  * [ ] Verify that tokens are long enough (e.g., ≥ 128 bits of entropy).

* [ ] Session keys are not stored in LocalStorage. Status:  Remarks:

  * [ ] Inspect frontend code for any use of `localStorage` or `sessionStorage` for session/token storage.
  * [ ] Review mobile apps for any insecure token storage in shared preferences or plist files.
  * [ ] Validate that tokens are stored in secure, HTTP-only cookies or encrypted device storage (e.g., Keychain/Keystore).

* [ ] Session keys are not stored in insecure cookies. Status:  Remarks:

  * [ ] Check that cookies storing session keys are set with `HttpOnly` and `Secure` flags.
  * [ ] Confirm `SameSite` attribute is configured (`Lax` or `Strict`) to prevent CSRF.
  * [ ] Inspect response headers to ensure no token leakage via misconfigured cookies.
  * [ ] Use browser dev tools or Burp Suite to verify cookie attributes on each request.

---

## Cookies Security

* [OWASP Cookie Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#cookie-based-session-handling)
* Mozilla MDN Web Docs on [Set-Cookie attributes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)
* OWASP ASVS v4.0 – Section 3 (Session Management)

* [ ] HttpOnly is enabled. Status:  Remarks:

  * [ ] Inspect the `Set-Cookie` response header to verify `HttpOnly` is present.
  * [ ] Ensure that session or authentication tokens are never accessible via JavaScript (`document.cookie`).
  * [ ] Test with XSS injection to attempt cookie theft—verify it's not accessible via script.
  * [ ] Use browser dev tools or security scanners to identify missing `HttpOnly` flags.

* [ ] Secure flag is enabled. Status:  Remarks:

  * [ ] Check all `Set-Cookie` headers to verify `Secure` is present for all sensitive cookies.
  * [ ] Confirm cookies are transmitted only over HTTPS—not over plaintext HTTP.
  * [ ] Scan application with a proxy to ensure cookies aren’t set on insecure endpoints.
  * [ ] Validate Secure flag is applied across all environments (dev, staging, prod).

* [ ] SameSite is not set to None. Status:  Remarks:

  * [ ] Ensure all cookies set `SameSite` to `Lax` or `Strict` (unless cross-site usage is explicitly needed).
  * [ ] Test login, sensitive actions, and CSRF vectors with and without `SameSite` enforcement.
  * [ ] Inspect the application behavior to validate that changing `SameSite` does not break core functionality.
  * [ ] Check for consistency across all cookies in multi-domain apps or when using third-party services.

* [ ] Proper expiration time is set. Status:  Remarks:

  * [ ] Review `Expires` or `Max-Age` attributes in the cookie headers.
  * [ ] Ensure session cookies are deleted upon browser close (no `Expires`).
  * [ ] Ensure long-lived cookies (e.g., remember me tokens) have a defined and reasonable lifespan.
  * [ ] Confirm that expired cookies are removed or replaced on the client side.
  * [ ] Validate token refresh or session renewal logic if long-term authentication is implemented.

* [ ] Scope is restricted with Domain and Path. Status:  Remarks:

  * [ ] Check `Set-Cookie` headers to ensure `Domain` and `Path` values are minimized to the necessary scope.
  * [ ] Avoid setting the cookie domain as a top-level domain (e.g., `.example.com`).
  * [ ] Confirm the path restriction ensures cookies are only sent where required (e.g., `/auth/`).
  * [ ] Test that cookies aren’t unnecessarily exposed to unrelated application sections.

---

## User Registration Security

* [ ] Secure CAPTCHA is implemented. Status:  Remarks:

  * [ ] Confirm CAPTCHA appears during account creation (e.g., Google reCAPTCHA, hCaptcha).
  * [ ] Check CAPTCHA is required and enforced server-side (bypassing client should fail).
  * [ ] Validate CAPTCHA isn't predictable or easily solvable by bots (e.g., image/audio analysis).
  * [ ] Ensure CAPTCHA doesn’t leak information (e.g., user enumeration via challenge presence).

---

## Password Reset Security

* [OWASP Forgot Password Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)
* [OWASP ASVS v4.0 – Section 2 (Authentication)](https://github.com/OWASP/ASVS)
* NIST SP 800-63B Password & Recovery Guidance


* [ ] Reset codes are in no way predictable. Status:  Remarks:

  * [ ] Inspect the format and length of reset tokens—ensure high entropy and randomness.
  * [ ] Validate token generation uses secure PRNG (e.g., `crypto.randomBytes`, `openssl_random_pseudo_bytes`).
  * [ ] Attempt brute-force/token prediction—verify rate-limiting or lockout is in place.
  * [ ] Avoid sequential or timestamp-based reset links.

* [ ] Expiration is sufficient for reset code. Status:  Remarks:

  * [ ] Confirm reset tokens have short, reasonable expiry (e.g., 15–30 minutes).
  * [ ] Test expired tokens manually to confirm proper rejection.
  * [ ] Review server-side logic for token expiration enforcement.
  * [ ] Ensure tokens are time-bound based on generation time, not user interaction.

* [ ] Reset codes are one use. Status:  Remarks:

  * [ ] Attempt to reuse a reset token after successful password change—access should be denied.
  * [ ] Confirm token is invalidated immediately upon use or expiration.
  * [ ] Validate backend stores token state securely and ensures atomic token invalidation.

* [ ] Emails are only delivered to registered users. Status:  Remarks:

  * [ ] Submit password reset for unregistered email—verify generic or no response is returned.
  * [ ] Confirm no registration or existence leaks (e.g., error message, email sent).
  * [ ] Test email delivery flow (e.g., via mail catcher) and verify only valid users receive it.
  * [ ] Review backend logic to suppress responses for unknown accounts.

* [ ] Destination email is not modifiable. Status:  Remarks:

  * [ ] Check UI/API for manipulation of email delivery address in reset flow.
  * [ ] Validate that reset tokens are only sent to the verified email address in the account.
  * [ ] Inspect frontend code for hidden inputs or JavaScript modifiable fields.
  * [ ] Confirm backend logic enforces recipient lock without trusting client-side data.

* [ ] Application behavior is standardized (User Enumeration). Status:  Remarks:

  * [ ] Trigger password reset on valid and invalid users—response should be identical (status, timing, message).
  * [ ] Use Burp to compare HTTP responses (status code, size, headers) for different usernames/emails.
  * [ ] Check rate of responses to avoid timing discrepancies revealing user existence.
  * [ ] Ensure generic messages like “If the email is valid, you will receive an email” are used.

* [ ] Secure CAPTCHA is implemented. Status:  Remarks:

  * [ ] Ensure CAPTCHA appears after N failed reset attempts (or on first request, if policy requires).
  * [ ] Test CAPTCHA bypass by sending automated reset requests—expect CAPTCHA validation server-side.
  * [ ] Confirm CAPTCHA is not reused or cached across reset flows.
  * [ ] Validate usability doesn’t suffer significantly for legitimate users.

---

## File Upload Security

* [OWASP Unrestricted File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unrestricted_File_Upload_Cheat_Sheet.html)
* [OWASP ASVS v4.0 – Section 14 (File and Resources)](https://github.com/OWASP/ASVS)
* Security scanner findings like those from Burp Suite and OWASP ZAP.


* [ ] Allowed file types are restricted. Status:  Remarks:

  * [ ] Review file upload endpoint to ensure only specific MIME types and extensions are permitted (e.g., `.jpg`, `.pdf`).
  * [ ] Attempt to upload unexpected file types (e.g., `.php`, `.exe`, `.sh`) and verify rejection.
  * [ ] Check whether MIME sniffing is prevented by validating against an explicit allowlist.
  * [ ] Inspect server-side validation logic—not just client-side JavaScript.

* [ ] Appropriate file format checks are implemented for allowed types. Status:  Remarks:

  * [ ] Analyze uploaded files using tools (e.g., `file`, `ExifTool`) to check for format spoofing.
  * [ ] Upload a file with correct extension but malformed or malicious content and verify it's detected.
  * [ ] Validate that uploaded images, PDFs, or documents are parsed and verified for internal structure.
  * [ ] Ensure anti-virus or sandboxing is used for complex or active content types.

* [ ] Content-Type is checked against a whitelist of allowed types. Status:  Remarks:

  * [ ] Capture upload requests with a proxy and manipulate `Content-Type` headers.
  * [ ] Verify server does not rely solely on `Content-Type` for validation—also check file signature/magic bytes.
  * [ ] Test with mismatched MIME type (e.g., sending an `.exe` as `image/png`) and ensure it's rejected.
  * [ ] Validate consistency between file extension, MIME type, and internal content.

* [ ] Unpredictable random names are defined for uploaded files. Status:  Remarks:

  * [ ] Upload a file and inspect the file name in the response or storage location.
  * [ ] Verify that original names are not used in URLs or paths.
  * [ ] Ensure filename includes sufficient entropy and avoids guessable patterns (e.g., timestamps, usernames).
  * [ ] Check whether the naming scheme leaks information about the uploader or internal logic.

* [ ] Extension of allowed file type is appended to uploaded file. Status:  Remarks:

  * [ ] Upload a file without an extension or with a misleading one and observe how it is stored.
  * [ ] Verify server automatically appends/forces allowed extensions (e.g., `.jpg`, `.pdf`) during storage.
  * [ ] Ensure no user-controlled data affects the file extension decision.
  * [ ] Test if application prevents double extensions (`file.php.jpg`) or null byte tricks (`file.jpg%00.php`).

* [ ] File destination is not modifiable by user. Status:  Remarks:

  * [ ] Attempt to manipulate path parameters in request (e.g., directory traversal `../`) and verify rejection.
  * [ ] Check if upload destination (path, bucket, key, etc.) is derived from user input.
  * [ ] Validate whether the file is stored in a segregated directory without user control.
  * [ ] Confirm the backend ignores filename/path hints from client-side fields or headers.

* [ ] All file type checks are done on the server side. Status:  Remarks:

  * [ ] Disable or bypass JavaScript checks in the browser (e.g., using dev tools or proxies).
  * [ ] Upload disallowed files and confirm they are rejected by the server backend.
  * [ ] Inspect the code or behavior to ensure file checks are implemented post-request, not during form validation.
  * [ ] Confirm that server logs or exceptions do not indicate missed validation paths.

---

## SSL/TLS Security

* [OWASP TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)
* [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/)
* [SSL Labs Server Test](https://www.ssllabs.com/ssltest/)

* [ ] Old SSL/TLS versions are not supported. Status:  Remarks:

  * [ ] Use tools like **SSL Labs**, **nmap**, or **testssl.sh** to identify supported protocols.

    * `nmap --script ssl-enum-ciphers -p 443 target.com`
    * `testssl.sh target.com`
  * [ ] Confirm **SSLv2**, **SSLv3**, and **TLS 1.0/1.1** are disabled.
  * [ ] Review web server or load balancer configuration (e.g., `nginx`, `Apache`, `AWS ELB`) to ensure `TLS 1.2+` is enforced.
  * [ ] Attempt to connect using older versions with `openssl s_client -tls1_0 -connect target.com:443`.

* [ ] Weak TLS ciphers are not supported. Status:  Remarks:

  * [ ] Scan server with **testssl.sh**, **SSL Labs**, or **nmap** to enumerate supported ciphers.
  * [ ] Ensure **NULL**, **RC4**, **DES**, **3DES**, **MD5-based**, and **EXPORT** ciphers are disabled.
  * [ ] Validate that **Forward Secrecy** ciphers (e.g., `ECDHE`, `DHE`) are prioritized.
  * [ ] Check for deprecated or insecure cipher suites in the server config (e.g., `ssl_ciphers` in nginx).

* [ ] Client-initiated TLS renegotiation is disabled. Status:  Remarks:

  * [ ] Use **testssl.sh** or **openssl s\_client -reconnect** to attempt renegotiation.
  * [ ] Review server settings to disable `ssl_renegotiation` if supported.
  * [ ] Verify no DoS vector via repeated renegotiation exists (some older OpenSSL versions are vulnerable).

* [ ] Data compression is disabled. Status:  Remarks:

  * [ ] Use **testssl.sh** to check for **TLS compression** (`CRIME` vulnerability).
  * [ ] Confirm `ssl_compression` is disabled in the server configuration.
  * [ ] Ensure the server does not support `Content-Encoding: gzip` compression over TLS for sensitive data transmission (e.g., session cookies, tokens).

---

## HTTP Server Security

* [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)
* [Mozilla Observatory](https://observatory.mozilla.org/)
* [OWASP Testing Guide - Web Server Configuration](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/04.3-Configuration_and_Deployment_Management_Testing/)

* [ ] Content Security Policy (CSP) is enabled. Status:  Remarks:

  * [ ] Check HTTP response headers for `Content-Security-Policy`.
  * [ ] Use **browser dev tools** (Network tab → Headers) or tools like **curl** or **securityheaders.com**.
  * [ ] Verify CSP restricts execution of inline scripts, external scripts, and other content sources (e.g., `default-src 'self';`).
  * [ ] Validate that `unsafe-inline` and overly permissive `*` directives are avoided.

* [ ] CSP is not loosely configured. Status:  Remarks:

  * [ ] Review policy for dangerous directives like:

    * `script-src *`, `script-src 'unsafe-inline'`, `style-src 'unsafe-inline'`
  * [ ] Test using tools like **Google CSP Evaluator** or **Mozilla Observatory**.
  * [ ] Try to inject scripts or content via XSS payloads and observe if blocked by CSP.
  * [ ] Ensure `report-uri` or `report-to` is configured for CSP violation monitoring.

* [ ] HTTP Strict Transport Security (HSTS) is enabled. Status:  Remarks:

  * [ ] Check response headers for `Strict-Transport-Security`.
  * [ ] Confirm it has `max-age=31536000; includeSubDomains; preload`.
  * [ ] Use browser dev tools or **curl -I [https://target.com](https://target.com)** to view headers.
  * [ ] Submit the domain to the [HSTS preload list](https://hstspreload.org/) if appropriate.

* [ ] X-Frame-Options header is enabled. Status:  Remarks:

  * [ ] Look for `X-Frame-Options: DENY` or `SAMEORIGIN` in the HTTP headers.
  * [ ] Try embedding the site in an `<iframe>` on another domain to test for clickjacking protection.
  * [ ] Prefer `Content-Security-Policy: frame-ancestors 'none';` for modern enforcement.

* [ ] Server version information is omitted. Status:  Remarks:

  * [ ] Check for `Server:` header in HTTP responses and identify if it leaks backend technology and versions (e.g., `Apache/2.4.41`).
  * [ ] Remove or generalize the header via web server config (`ServerTokens Prod`, `ServerSignature Off`, etc.).
  * [ ] Scan using **whatweb**, **nikto**, or **nmap** to detect version disclosure.

* [ ] Custom error pages are used to prevent information leaks. Status:  Remarks:

  * [ ] Trigger errors (e.g., 404, 500) and inspect responses for stack traces, internal paths, or debug info.
  * [ ] Ensure custom error pages do not expose implementation details.
  * [ ] Validate that logs are still informative for admins, even if the user-facing error is generic.

* [ ] Directory listing is disabled. Status:  Remarks:

  * [ ] Access known or guessed directory paths (e.g., `/images/`, `/uploads/`, `/css/`) without index files.
  * [ ] Ensure the server returns a 403 Forbidden or 404 Not Found instead of a file list.
  * [ ] Confirm `Options -Indexes` or equivalent is configured on the web server (e.g., Apache, nginx).

---

## Network Security

- [ ] Requests rate-limited. Status:  Remarks: 
    - [ ] Send bursts of requests and watch for throttling.  
    - [ ] Review WAF/NGINX rate-limit rules.

- [ ] Web Application Firewall deployed. Status:  Remarks: 
    - [ ] Trigger known attack patterns and observe blocking.  
    - [ ] Check WAF headers (`ModSecurity`, `Cloudflare`).

- [ ] Direct web server access blocked. Status:  Remarks: 
    - [ ] Attempt to connect to server’s IP over HTTP.  
    - [ ] Ensure only frontend/load-balancer accessible.

- [ ] Service version banners disabled. Status:  Remarks: 
    - [ ] Scan open ports (SSH, FTP) for banners.  
    - [ ] Confirm generic responses.

- [ ] All services up-to-date. Status:  Remarks: 
    - [ ] Check package versions (`dpkg -l`, `yum list`).  
    - [ ] Compare against CVE databases.

---

## DNS Security

- [ ] No dangling DNS records. Status:  Remarks: 
    - [ ] Enumerate subdomains via `amass`, `sublist3r`.  
    - [ ] Verify none resolve to 404 or default pages.

- [ ] Public access to primary DNS blocked. Status:  Remarks: 
    - [ ] Attempt DNS queries against primary nameserver.  
    - [ ] Confirm recursion is disabled.

- [ ] Zone transfers disabled. Status:  Remarks:  
    - [ ] Test `dig AXFR domain.com @ns1.domain.com`.  
    - [ ] Ensure transfer is refused.

- [ ] Recursive & authoritative servers separated. Status:  Remarks: 
    - [ ] Identify NS records and roles.  
    - [ ] Confirm no overlap in `dig +trace`.

---

## Mobile Security

- [ ] No unsafe deserialization. (MASTG-TEST-0038) Status:  Remarks: 
    - [ ] Review code for `ObjectInputStream`/`Gson` dynamic typing.  
    - [ ] Fuzz serialized payloads via Frida.

- [ ] No unsafe object persistence. (MASTG-TEST-0034) Status:  Remarks: 
    - [ ] Inspect SharedPreferences and file storage for unsecured objects.  
    - [ ] Attempt to modify persisted data.

- [ ] No sensitive data in notifications. (MASTG-TEST-0005) Status:  Remarks: 
    - [ ] Trigger notifications and review content on lock screen.  
    - [ ] Check notification channel settings.

- [ ] Intents are secured. (MASTG-TEST-0026, MASTG-TEST-0030) Status:  Remarks: 
    - [ ] Enumerate exported activities/services via `aapt`.  
    - [ ] Attempt to send unauthorized intents.

- [ ] Injection flaws tested. (MASTG-TEST-0025) Status:  Remarks: 
    - [ ] Test SQLite/WebView JS injection scenarios.  
    - [ ] Review code for direct SQL concatenation.

- [ ] No JavaScript injection in WebViews. (MASTG-TEST-0031) Status:  Remarks: 
    - [ ] Inject JS via URL parameters and observe execution.  
    - [ ] Verify `setJavaScriptEnabled(false)` where appropriate.

- [ ] No Java objects exposed in WebViews. (MASTG-TEST-0033) Status:  Remarks: 
    - [ ] Review `addJavascriptInterface` usage.  
    - [ ] Ensure `@JavascriptInterface` only on safe methods.

- [ ] No native methods exposed in WebViews. (MASTG-TEST-0078) Status:  Remarks: 
    - [ ] Inspect `System.loadLibrary` calls.  
    - [ ] Ensure no unvalidated JNI entry points.

- [ ] URL loading in WebViews is safe. (MASTG-TEST-0027) Status:  Remarks: 
    - [ ] Test `shouldOverrideUrlLoading` for open redirects.  
    - [ ] Confirm allowlist of schemes.

- [ ] Protocol handlers in WebViews are safe. (MASTG-TEST-0032, MASTG-TEST-0077) Status:  Remarks: 
    - [ ] Try `intent://` and custom schemes.  
    - [ ] Verify handling in code.

- [ ] Deep links are securely implemented. (MASTG-TEST-0028) Status:  Remarks: 
    - [ ] Enumerate `<intent-filter>` in `AndroidManifest`.  
    - [ ] Test link invocation from external apps.

- [ ] Custom URL schemes are secure. (MASTG-TEST-0075) Status:  Remarks: 
    - [ ] Register and test app-specific schemes.  
    - [ ] Ensure no interception by other apps.

- [ ] Universal links are securely implemented. (MASTG-TEST-0070) Status:  Remarks: 
    - [ ] Verify `apple-app-site-association` / `assetlinks.json` files.  
    - [ ] Test link opening behavior.

- [ ] No unintended IPC functionality exposed. (MASTG-TEST-0029) Status:  Remarks: 
    - [ ] List all AIDL/Binder interfaces.  
    - [ ] Attempt direct IPC calls.

- [ ] No sensitive data exposed via IPC. (MASTG-TEST-0007, MASTG-TEST-0056) Status:  Remarks: 
    - [ ] Inspect `ContentProvider` URIs and permissions.  
    - [ ] Try reading from providers without permission.

- [ ] App extensions do not leak data. (MASTG-TEST-0072) Status:  Remarks: 
    - [ ] Review `AppExtension` entitlements in iOS.  
    - [ ] Test data exchange between host and extension.

- [ ] Dependency checking is in place. (MASTG-TEST-0042) Status:  Remarks: 
    - [ ] Verify use of OWASP Dependency-Check plugin.  
    - [ ] Review generated reports for vulnerable libs.

---